there's a function called validate name, which takes a char* and
probably has to do with accepting or rejecting our input :D

breaks at get_string, process and validate_name do not appear to 
break, or do I need to `set follow-fork-mode child'??

It must be because I didn't attach to the process early enough.

the validate_name function references the string `z@Z/9# via 
direct comparisions (a la cmp al, 0x39). So What happends if we
give it that string?

*process* Function observations:

+ *Locals:*
  + ebp-0x11c = username (char [64])
  + ebp-0xdc  = password (char [64])
  + ebp-0x9c  = email    (char [64])
  + ebp-0x8   = again    (char [64])
  + ebp-0x91c = result   (char [2048])
  + ebp-0x920 = wh00p    (char *)
  *Where is*:
  

Protected by SSP, it starts of by zeroing out locals username, password and
email in that order (using the rep stos... instruction)

Directly after zeroing out the three local variables, it sets up
some registers - along with the stack for a call into get_string,

Calls looks like this:

~~~
get_string(username_prompt, username, 63);
get_string(password_prompt, password, 63);
get_string(email_prompt, email, 63);
~~~

Now it turns to create the prompt that creation failed, call could
be translated as this:

`asprintf(wh00p, prompt, username, password, email)`

after that, result contains the crafted string. It's then moved into
eax, and further onto the stack - where it's then used in a call to
fprintf - with two arguments. `fprintf(ebx-0x10, result)` where
ebx-0x10 == stdout. effectively making the call `fprintf(stdout,
result)` which is where the formatting exploit is first 'triggered'

After the call to fprintf, there's a couple of values on the stack.

+ _IO_2_1_stdout_
+ mallocd prompt ("So your username is 'chungus'...)
+ pointer_to_username
+ pointer_to_password
+ pointer_to_email
+ 5 null pointers
+ mallocd prompt
+ about 120 more null pointers, then unknown value/address. Possibly a
  return address.

The final comparision, useing repz cmps, checks 4 bytes in the local
variable `again`, compared to a static 'yes\0' accessed via ebx. 

:QUESTION/UNCLEAR: It should be possible to simply get more input into this
variable, but... to what end? Do we get any benefit from doing so?

We do have access to our old friends *nread* and *nwrite*, along with
a symbolic reference to execve. Good times. Provided we can overwrite
a entry to exit, we can probably achieve code execution, as it is called
after return to main, if again != "yes\0".

Finding these functions would be easy, as I could simply rely on a offset
from the stack, atleast to reference them in, for example %index_of_execve$08x
When finding the offset, maybe it would be useful to make a mini-signature
for each function. 

~~~
(gdb) x/g execve
0xb7784910 <__execve>: 0x548b241c8908ec83
~~~

Not sure this would in fact work though, as it's possible that this is
a common function preamble. It probably is, as x86 is wonky in that way.

*validate_name* Function observations:
+ :GENERAL: This function references the executable which launched
  it, as a anti-debugging trick? no, why would I be able to reference
  the value by hand IN gdb? 
+ :GENERAL: I *feel* like this function is here just to mess with me.
  I *think* it's just some anti-debugging bogaboo, since it's causing
  the child process to quit upon returning to background_process.
+ *And* it's a part of the common.c library, which has never been the
  target in previous levels.

+ ebx contains the GOT (set @ 0xea0)
+ it takes one argument, which could be 8 bytes.
+ it has 4 local integer variables, could be pointers.
+ zeroes out third local integer (set @ 0xea6)
+ It does a unconditional jump to 0xf3c.
  + Now it moves the third local integer, which was earlier set to 0. (could be a counter)
  + It adds the parameter (which more likely is a normal integer, not a 8byte parameter)
  + it performs a movzx (move with zero extend) from a byte pointed to by eax, into eax
  + checks if al == 0
    + If not 0, then jump to 0xeb2
  + if == 0, return
+ 0xeb2
  + moves the value pointed at by the third local integer (local_ch), into eax
  + it adds (again) the given argument, to eax,
  + and, yet again, it performs a movzx of a byte pointed to by eax, into eax
  + this byte, contained in al is compared to 0x60 ('`')
    + if less than or equal, jump to 0xecc
  + else, continue
+ 0xebf
  + 
+ 0xecc - local_ch is moved into eax, eax is incremented by the
  argument, and moved (movzx) into eax is the byte pointed to by
  eax.
  + If al <= 0x40 ('@'), jump to 0xee6
+ 0xee6
  ...

It does appear that "yes" *is* located on the stack... Is it possible to insert pointers there?

