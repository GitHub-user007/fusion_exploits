package main

import (
	"fmt"
	"log"
	"sort"
	"math"
	"encoding/csv"
	"strconv"
	"os"
)

var (
	s int
	p []byte
	d map[string]sort.IntSlice
	w *csv.Writer
	r *csv.Reader
)

func check(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func main() {
	p = []byte("!!!!!!!!!!!!!!!!")
	w = csv.NewWriter(os.Stdout)
	r = csv.NewReader(os.Stdin)
	data, err := r.ReadAll()
	check(err)

	for i := range(p) {
		// each index in our password should be using a clean version
		// of d. Thus the reset.
		d = make(map[string]sort.IntSlice)
	inner:
		for _, row := range(data) {
			var (
				Δ int
			)
			// We go index by index over the password-string,
			// since our blob dataset contains all indices -
			// we do some selection of said dataset
			index, err := strconv.Atoi(row[2])
			check(err)
			if index != i {
				continue inner
			}
			
			// Δ is delta. Shoutouts to golang for being unicode-friendly.
			Δ, err = strconv.Atoi(row[0])
			check(err)

			// Note that our dataset, because of timing-attack good practice
			// half of all tests we've collected... regardless of if we should
			// have collected them in the first place - are exclamation-chars
			// Needless to say, we skip those points, as they are uninteresting
			// for our purpose (they are garantueed to be false)
			char := row[1]
			if char == "!" {
				continue inner
			}

			// at this point, we have jumped through enough hoops to begin
			// reason about the data we've collected.
			//fmt.Printf("%v %s %v\n", Δ, char, index)

			// first check that we've created a slice for character char
			_, ok := d[char]
			if !ok {
				d[char] = sort.IntSlice{}
			}
			d[char] = append(d[char], Δ)
		}

		var best int = math.MaxInt32
		
		for char := range(d) {
			sort.Sort(d[char])
			if d[char][50] < best {
				best = d[char][49]
				p[i] = char[0]
			}
		}
	}
	fmt.Printf("%s\n", p)
}

